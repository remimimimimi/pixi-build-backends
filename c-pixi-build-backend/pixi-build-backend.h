/*! \file */
/*******************************************
 *                                         *
 *  File auto-generated by `::safer_ffi`.  *
 *                                         *
 *  Do not manually edit this file.        *
 *                                         *
 *******************************************/

#ifndef __RUST_C_PIXI_BUILD_BACKEND__
#define __RUST_C_PIXI_BUILD_BACKEND__
#ifdef __cplusplus
extern "C" {
#endif

/** <No documentation available> */
typedef struct CBackendConfig CBackendConfig_t;

/** <No documentation available> */
char *
pbb_backend_config_debug_dir (
    CBackendConfig_t const * config);

/** <No documentation available> */
char *
pbb_backend_config_merge_with_target (
    CBackendConfig_t const * base,
    CBackendConfig_t const * target,
    CBackendConfig_t * * output);

/** <No documentation available> */
typedef struct ConfigValue ConfigValue_t;

/** <No documentation available> */
ConfigValue_t *
pbb_backend_config_raw_value (
    CBackendConfig_t const * config);

/** <No documentation available> */
typedef struct Generator Generator_t;


#include <stddef.h>
#include <stdint.h>

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_char_const_ptr {
    /** \brief
     *  Pointer to the first element (if any).
     */
    char const * const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_char_const_ptr_t;

/** <No documentation available> */
char *
pbb_cli_run (
    Generator_t const * generator,
    slice_ref_char_const_ptr_t args);

/** <No documentation available> */
ConfigValue_t *
pbb_config_value_array_get (
    ConfigValue_t const * value,
    size_t index);


#include <stdbool.h>

/** <No documentation available> */
bool
pbb_config_value_array_len (
    ConfigValue_t const * value,
    size_t * output);

/** <No documentation available> */
bool
pbb_config_value_as_bool (
    ConfigValue_t const * value,
    bool * output);

/** <No documentation available> */
bool
pbb_config_value_as_f64 (
    ConfigValue_t const * value,
    double * output);

/** <No documentation available> */
bool
pbb_config_value_as_i64 (
    ConfigValue_t const * value,
    int64_t * output);

/** <No documentation available> */
char *
pbb_config_value_as_string (
    ConfigValue_t const * value);

/** <No documentation available> */
bool
pbb_config_value_as_u64 (
    ConfigValue_t const * value,
    uint64_t * output);

/** <No documentation available> */
void
pbb_config_value_free (
    ConfigValue_t * value);

/** <No documentation available> */
/** \remark Has the same ABI as `uint8_t` **/
#ifdef DOXYGEN
typedef
#endif
enum ConfigValueKind {
    /** <No documentation available> */
    CONFIG_VALUE_KIND_NULL,
    /** <No documentation available> */
    CONFIG_VALUE_KIND_BOOL,
    /** <No documentation available> */
    CONFIG_VALUE_KIND_NUMBER,
    /** <No documentation available> */
    CONFIG_VALUE_KIND_STRING,
    /** <No documentation available> */
    CONFIG_VALUE_KIND_ARRAY,
    /** <No documentation available> */
    CONFIG_VALUE_KIND_OBJECT,
}
#ifndef DOXYGEN
; typedef uint8_t
#endif
ConfigValueKind_t;

/** <No documentation available> */
ConfigValueKind_t
pbb_config_value_kind (
    ConfigValue_t const * value);

/** <No documentation available> */
ConfigValue_t *
pbb_config_value_object_get (
    ConfigValue_t const * value,
    char const * key);

/** <No documentation available> */
char *
pbb_config_value_to_json (
    ConfigValue_t const * value);

/** <No documentation available> */
typedef struct GeneratedRecipeHandle GeneratedRecipeHandle_t;

/** <No documentation available> */
char *
pbb_generated_recipe_add_build_glob (
    GeneratedRecipeHandle_t * recipe,
    char const * glob);

/** <No documentation available> */
char *
pbb_generated_recipe_add_metadata_glob (
    GeneratedRecipeHandle_t * recipe,
    char const * glob);

/** <No documentation available> */
char *
pbb_generated_recipe_build_glob_at (
    GeneratedRecipeHandle_t const * recipe,
    size_t index);

/** <No documentation available> */
size_t
pbb_generated_recipe_build_glob_count (
    GeneratedRecipeHandle_t const * recipe);

/** <No documentation available> */
void
pbb_generated_recipe_clear_build_globs (
    GeneratedRecipeHandle_t * recipe);

/** <No documentation available> */
void
pbb_generated_recipe_clear_metadata_globs (
    GeneratedRecipeHandle_t * recipe);

/** <No documentation available> */
GeneratedRecipeHandle_t *
pbb_generated_recipe_clone (
    GeneratedRecipeHandle_t const * recipe);

/** <No documentation available> */
char *
pbb_generated_recipe_from_json (
    char const * json,
    GeneratedRecipeHandle_t * * output);

/** <No documentation available> */
typedef struct IntermediateRecipeHandle IntermediateRecipeHandle_t;

/** <No documentation available> */
IntermediateRecipeHandle_t *
pbb_generated_recipe_get_intermediate (
    GeneratedRecipeHandle_t * recipe);

/** <No documentation available> */
char *
pbb_generated_recipe_metadata_glob_at (
    GeneratedRecipeHandle_t const * recipe,
    size_t index);

/** <No documentation available> */
size_t
pbb_generated_recipe_metadata_glob_count (
    GeneratedRecipeHandle_t const * recipe);

/** <No documentation available> */
GeneratedRecipeHandle_t *
pbb_generated_recipe_new_empty (void);

/** <No documentation available> */
void
pbb_generated_recipe_release (
    GeneratedRecipeHandle_t * recipe);

/** <No documentation available> */
void
pbb_generated_recipe_set_intermediate (
    GeneratedRecipeHandle_t * recipe,
    IntermediateRecipeHandle_t * intermediate);

/** <No documentation available> */
char *
pbb_generated_recipe_to_json (
    GeneratedRecipeHandle_t const * recipe);

/** <No documentation available> */
typedef struct Erased Erased_t;

/** <No documentation available> */
typedef struct CGeneratorVTable {
    /** <No documentation available> */
    void (*release_vptr)(Erased_t *);

    /** <No documentation available> */
    char * (*generate_recipe)(Erased_t *, char const *, char const *, char const *, char const *, bool, char const *, GeneratedRecipeHandle_t * *);

    /** <No documentation available> */
    char * (*extract_input_globs_from_build)(Erased_t *, char const *, char const *, bool, char * *);

    /** <No documentation available> */
    char * (*default_variants)(Erased_t *, char const *, char * *);
} CGeneratorVTable_t;

/** <No documentation available> */
typedef struct VirtualPtr__Erased_ptr_CGeneratorVTable {
    /** <No documentation available> */
    Erased_t * ptr;

    /** <No documentation available> */
    CGeneratorVTable_t vtable;
} VirtualPtr__Erased_ptr_CGeneratorVTable_t;

/** <No documentation available> */
Generator_t *
pbb_generator_new (
    VirtualPtr__Erased_ptr_CGeneratorVTable_t generator);

/** \brief
 *  A reference to a specific commit in a git repository.
 */
typedef struct GitReferenceV1 GitReferenceV1_t;

/** <No documentation available> */
GitReferenceV1_t *
pbb_git_reference_v1_branch_new (
    char * branch);

/** <No documentation available> */
GitReferenceV1_t *
pbb_git_reference_v1_default_branch_new (void);

/** <No documentation available> */
GitReferenceV1_t *
pbb_git_reference_v1_rev_new (
    char * rev);

/** <No documentation available> */
GitReferenceV1_t *
pbb_git_reference_v1_tag_new (
    char * tag);

/** <No documentation available> */
char *
pbb_intermediate_recipe_add_build_requirement (
    IntermediateRecipeHandle_t * recipe,
    char const * spec,
    bool is_template);

/** <No documentation available> */
typedef struct RequirementInput {
    /** <No documentation available> */
    char * spec;

    /** <No documentation available> */
    bool is_template;
} RequirementInput_t;

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_RequirementInput {
    /** \brief
     *  Pointer to the first element (if any).
     */
    RequirementInput_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_RequirementInput_t;

/** <No documentation available> */
char *
pbb_intermediate_recipe_add_build_requirement_conditional (
    IntermediateRecipeHandle_t * recipe,
    char const * condition,
    slice_ref_RequirementInput_t then_specs,
    slice_ref_RequirementInput_t else_specs);

/** <No documentation available> */
char *
pbb_intermediate_recipe_add_host_requirement (
    IntermediateRecipeHandle_t * recipe,
    char const * spec,
    bool is_template);

/** <No documentation available> */
char *
pbb_intermediate_recipe_add_host_requirement_conditional (
    IntermediateRecipeHandle_t * recipe,
    char const * condition,
    slice_ref_RequirementInput_t then_specs,
    slice_ref_RequirementInput_t else_specs);

/** <No documentation available> */
char *
pbb_intermediate_recipe_add_run_constraint (
    IntermediateRecipeHandle_t * recipe,
    char const * spec,
    bool is_template);

/** <No documentation available> */
char *
pbb_intermediate_recipe_add_run_constraint_conditional (
    IntermediateRecipeHandle_t * recipe,
    char const * condition,
    slice_ref_RequirementInput_t then_specs,
    slice_ref_RequirementInput_t else_specs);

/** <No documentation available> */
char *
pbb_intermediate_recipe_add_run_requirement (
    IntermediateRecipeHandle_t * recipe,
    char const * spec,
    bool is_template);

/** <No documentation available> */
char *
pbb_intermediate_recipe_add_run_requirement_conditional (
    IntermediateRecipeHandle_t * recipe,
    char const * condition,
    slice_ref_RequirementInput_t then_specs,
    slice_ref_RequirementInput_t else_specs);

/** <No documentation available> */
/** \remark Has the same ABI as `uint8_t` **/
#ifdef DOXYGEN
typedef
#endif
enum SourceKind {
    /** <No documentation available> */
    SOURCE_KIND_URL,
    /** <No documentation available> */
    SOURCE_KIND_PATH,
    /** <No documentation available> */
    SOURCE_KIND_CONDITIONAL,
}
#ifndef DOXYGEN
; typedef uint8_t
#endif
SourceKind_t;

/** <No documentation available> */
typedef struct SourceInput {
    /** <No documentation available> */
    SourceKind_t kind;

    /** <No documentation available> */
    char * value;

    /** <No documentation available> */
    bool value_is_template;

    /** <No documentation available> */
    char * sha256;

    /** <No documentation available> */
    bool sha256_is_template;
} SourceInput_t;

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_SourceInput {
    /** \brief
     *  Pointer to the first element (if any).
     */
    SourceInput_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_SourceInput_t;

/** <No documentation available> */
char *
pbb_intermediate_recipe_add_source_conditional (
    IntermediateRecipeHandle_t * recipe,
    char const * condition,
    slice_ref_SourceInput_t then_sources,
    slice_ref_SourceInput_t else_sources);

/** <No documentation available> */
void
pbb_intermediate_recipe_add_source_path (
    IntermediateRecipeHandle_t * recipe,
    char const * path,
    bool path_is_template,
    char const * sha256,
    bool sha256_is_template);

/** <No documentation available> */
void
pbb_intermediate_recipe_add_source_url (
    IntermediateRecipeHandle_t * recipe,
    char const * url,
    bool url_is_template,
    char const * sha256,
    bool sha256_is_template);

/** <No documentation available> */
void
pbb_intermediate_recipe_build_script_add_secret (
    IntermediateRecipeHandle_t * recipe,
    char const * secret);

/** <No documentation available> */
void
pbb_intermediate_recipe_build_script_clear_env (
    IntermediateRecipeHandle_t * recipe);

/** <No documentation available> */
void
pbb_intermediate_recipe_build_script_clear_secrets (
    IntermediateRecipeHandle_t * recipe);

/** <No documentation available> */
char *
pbb_intermediate_recipe_build_script_env_at (
    IntermediateRecipeHandle_t const * recipe,
    size_t index,
    char * * out_key,
    char * * out_value);

/** <No documentation available> */
size_t
pbb_intermediate_recipe_build_script_env_len (
    IntermediateRecipeHandle_t const * recipe);

/** <No documentation available> */
void
pbb_intermediate_recipe_build_script_remove_env (
    IntermediateRecipeHandle_t * recipe,
    char const * key);

/** <No documentation available> */
char *
pbb_intermediate_recipe_build_script_secret_at (
    IntermediateRecipeHandle_t const * recipe,
    size_t index,
    char * * output);

/** <No documentation available> */
size_t
pbb_intermediate_recipe_build_script_secrets_len (
    IntermediateRecipeHandle_t const * recipe);

/** <No documentation available> */
void
pbb_intermediate_recipe_build_script_set_env (
    IntermediateRecipeHandle_t * recipe,
    char const * key,
    char const * value);

/** <No documentation available> */
void
pbb_intermediate_recipe_clear_sources (
    IntermediateRecipeHandle_t * recipe);

/** <No documentation available> */
IntermediateRecipeHandle_t *
pbb_intermediate_recipe_clone (
    IntermediateRecipeHandle_t const * recipe);

/** <No documentation available> */
void
pbb_intermediate_recipe_extra_add_maintainer (
    IntermediateRecipeHandle_t * recipe,
    char const * maintainer);

/** <No documentation available> */
void
pbb_intermediate_recipe_extra_clear_maintainers (
    IntermediateRecipeHandle_t * recipe);

/** <No documentation available> */
char *
pbb_intermediate_recipe_extra_get_maintainer (
    IntermediateRecipeHandle_t const * recipe,
    size_t index,
    char * * output);

/** <No documentation available> */
size_t
pbb_intermediate_recipe_extra_maintainers_len (
    IntermediateRecipeHandle_t const * recipe);

/** <No documentation available> */
char *
pbb_intermediate_recipe_extra_remove_maintainer (
    IntermediateRecipeHandle_t * recipe,
    size_t index);

/** <No documentation available> */
char *
pbb_intermediate_recipe_from_yaml (
    char const * yaml,
    IntermediateRecipeHandle_t * * output);

/** <No documentation available> */
char *
pbb_intermediate_recipe_get_about_description (
    IntermediateRecipeHandle_t const * recipe,
    char * * output);

/** <No documentation available> */
char *
pbb_intermediate_recipe_get_about_documentation (
    IntermediateRecipeHandle_t const * recipe,
    char * * output);

/** <No documentation available> */
char *
pbb_intermediate_recipe_get_about_homepage (
    IntermediateRecipeHandle_t const * recipe,
    char * * output);

/** <No documentation available> */
char *
pbb_intermediate_recipe_get_about_license (
    IntermediateRecipeHandle_t const * recipe,
    char * * output);

/** <No documentation available> */
char *
pbb_intermediate_recipe_get_about_license_file (
    IntermediateRecipeHandle_t const * recipe,
    char * * output);

/** <No documentation available> */
char *
pbb_intermediate_recipe_get_about_repository (
    IntermediateRecipeHandle_t const * recipe,
    char * * output);

/** <No documentation available> */
char *
pbb_intermediate_recipe_get_build_number (
    IntermediateRecipeHandle_t const * recipe,
    bool * out_present,
    uint64_t * out_value);

/** <No documentation available> */
char *
pbb_intermediate_recipe_get_build_script (
    IntermediateRecipeHandle_t const * recipe,
    char * * output);

/** <No documentation available> */
/** \remark Has the same ABI as `uint8_t` **/
#ifdef DOXYGEN
typedef
#endif
enum NoArchKind {
    /** <No documentation available> */
    NO_ARCH_KIND_NONE,
    /** <No documentation available> */
    NO_ARCH_KIND_PYTHON,
    /** <No documentation available> */
    NO_ARCH_KIND_GENERIC,
}
#ifndef DOXYGEN
; typedef uint8_t
#endif
NoArchKind_t;

/** <No documentation available> */
NoArchKind_t
pbb_intermediate_recipe_get_noarch (
    IntermediateRecipeHandle_t const * recipe);

/** <No documentation available> */
char *
pbb_intermediate_recipe_get_package (
    IntermediateRecipeHandle_t const * recipe,
    char * * out_name,
    char * * out_version);

/** <No documentation available> */
IntermediateRecipeHandle_t *
pbb_intermediate_recipe_new (void);

/** <No documentation available> */
void
pbb_intermediate_recipe_python_add_entry_point (
    IntermediateRecipeHandle_t * recipe,
    char const * command,
    char const * module,
    char const * function);

/** <No documentation available> */
void
pbb_intermediate_recipe_python_clear_entry_points (
    IntermediateRecipeHandle_t * recipe);

/** <No documentation available> */
char *
pbb_intermediate_recipe_python_entry_point_at (
    IntermediateRecipeHandle_t const * recipe,
    size_t index,
    char * * out_command,
    char * * out_module,
    char * * out_function);

/** <No documentation available> */
size_t
pbb_intermediate_recipe_python_entry_points_len (
    IntermediateRecipeHandle_t const * recipe);

/** <No documentation available> */
bool
pbb_intermediate_recipe_python_is_default (
    IntermediateRecipeHandle_t const * recipe);

/** <No documentation available> */
char *
pbb_intermediate_recipe_python_remove_entry_point_at (
    IntermediateRecipeHandle_t * recipe,
    size_t index);

/** <No documentation available> */
void
pbb_intermediate_recipe_release (
    IntermediateRecipeHandle_t * recipe);

/** <No documentation available> */
char *
pbb_intermediate_recipe_requirements_build_at (
    IntermediateRecipeHandle_t const * recipe,
    size_t index,
    char * * output);

/** <No documentation available> */
/** \remark Has the same ABI as `uint8_t` **/
#ifdef DOXYGEN
typedef
#endif
enum ConditionalBranch {
    /** <No documentation available> */
    CONDITIONAL_BRANCH_THEN,
    /** <No documentation available> */
    CONDITIONAL_BRANCH_ELSE,
}
#ifndef DOXYGEN
; typedef uint8_t
#endif
ConditionalBranch_t;

/** <No documentation available> */
char *
pbb_intermediate_recipe_requirements_build_conditional_add (
    IntermediateRecipeHandle_t * recipe,
    size_t index,
    ConditionalBranch_t branch,
    char const * spec);

/** <No documentation available> */
char *
pbb_intermediate_recipe_requirements_build_conditional_at (
    IntermediateRecipeHandle_t const * recipe,
    size_t index,
    ConditionalBranch_t branch,
    size_t branch_index,
    char * * output);

/** <No documentation available> */
char *
pbb_intermediate_recipe_requirements_build_conditional_info (
    IntermediateRecipeHandle_t const * recipe,
    size_t index,
    char * * out_condition,
    size_t * out_then_len,
    size_t * out_else_len);

/** <No documentation available> */
char *
pbb_intermediate_recipe_requirements_build_conditional_remove (
    IntermediateRecipeHandle_t * recipe,
    size_t index,
    ConditionalBranch_t branch,
    size_t branch_index);

/** <No documentation available> */
size_t
pbb_intermediate_recipe_requirements_build_len (
    IntermediateRecipeHandle_t const * recipe);

/** <No documentation available> */
char *
pbb_intermediate_recipe_requirements_build_remove (
    IntermediateRecipeHandle_t * recipe,
    size_t index);

/** <No documentation available> */
void
pbb_intermediate_recipe_requirements_clear_build (
    IntermediateRecipeHandle_t * recipe);

/** <No documentation available> */
void
pbb_intermediate_recipe_requirements_clear_host (
    IntermediateRecipeHandle_t * recipe);

/** <No documentation available> */
void
pbb_intermediate_recipe_requirements_clear_run (
    IntermediateRecipeHandle_t * recipe);

/** <No documentation available> */
void
pbb_intermediate_recipe_requirements_clear_run_constraints (
    IntermediateRecipeHandle_t * recipe);

/** <No documentation available> */
char *
pbb_intermediate_recipe_requirements_host_at (
    IntermediateRecipeHandle_t const * recipe,
    size_t index,
    char * * output);

/** <No documentation available> */
char *
pbb_intermediate_recipe_requirements_host_conditional_add (
    IntermediateRecipeHandle_t * recipe,
    size_t index,
    ConditionalBranch_t branch,
    char const * spec);

/** <No documentation available> */
char *
pbb_intermediate_recipe_requirements_host_conditional_at (
    IntermediateRecipeHandle_t const * recipe,
    size_t index,
    ConditionalBranch_t branch,
    size_t branch_index,
    char * * output);

/** <No documentation available> */
char *
pbb_intermediate_recipe_requirements_host_conditional_info (
    IntermediateRecipeHandle_t const * recipe,
    size_t index,
    char * * out_condition,
    size_t * out_then_len,
    size_t * out_else_len);

/** <No documentation available> */
char *
pbb_intermediate_recipe_requirements_host_conditional_remove (
    IntermediateRecipeHandle_t * recipe,
    size_t index,
    ConditionalBranch_t branch,
    size_t branch_index);

/** <No documentation available> */
size_t
pbb_intermediate_recipe_requirements_host_len (
    IntermediateRecipeHandle_t const * recipe);

/** <No documentation available> */
char *
pbb_intermediate_recipe_requirements_host_remove (
    IntermediateRecipeHandle_t * recipe,
    size_t index);

/** <No documentation available> */
char *
pbb_intermediate_recipe_requirements_run_at (
    IntermediateRecipeHandle_t const * recipe,
    size_t index,
    char * * output);

/** <No documentation available> */
char *
pbb_intermediate_recipe_requirements_run_conditional_add (
    IntermediateRecipeHandle_t * recipe,
    size_t index,
    ConditionalBranch_t branch,
    char const * spec);

/** <No documentation available> */
char *
pbb_intermediate_recipe_requirements_run_conditional_at (
    IntermediateRecipeHandle_t const * recipe,
    size_t index,
    ConditionalBranch_t branch,
    size_t branch_index,
    char * * output);

/** <No documentation available> */
char *
pbb_intermediate_recipe_requirements_run_conditional_info (
    IntermediateRecipeHandle_t const * recipe,
    size_t index,
    char * * out_condition,
    size_t * out_then_len,
    size_t * out_else_len);

/** <No documentation available> */
char *
pbb_intermediate_recipe_requirements_run_conditional_remove (
    IntermediateRecipeHandle_t * recipe,
    size_t index,
    ConditionalBranch_t branch,
    size_t branch_index);

/** <No documentation available> */
char *
pbb_intermediate_recipe_requirements_run_constraints_at (
    IntermediateRecipeHandle_t const * recipe,
    size_t index,
    char * * output);

/** <No documentation available> */
char *
pbb_intermediate_recipe_requirements_run_constraints_conditional_add (
    IntermediateRecipeHandle_t * recipe,
    size_t index,
    ConditionalBranch_t branch,
    char const * spec);

/** <No documentation available> */
char *
pbb_intermediate_recipe_requirements_run_constraints_conditional_at (
    IntermediateRecipeHandle_t const * recipe,
    size_t index,
    ConditionalBranch_t branch,
    size_t branch_index,
    char * * output);

/** <No documentation available> */
char *
pbb_intermediate_recipe_requirements_run_constraints_conditional_info (
    IntermediateRecipeHandle_t const * recipe,
    size_t index,
    char * * out_condition,
    size_t * out_then_len,
    size_t * out_else_len);

/** <No documentation available> */
char *
pbb_intermediate_recipe_requirements_run_constraints_conditional_remove (
    IntermediateRecipeHandle_t * recipe,
    size_t index,
    ConditionalBranch_t branch,
    size_t branch_index);

/** <No documentation available> */
size_t
pbb_intermediate_recipe_requirements_run_constraints_len (
    IntermediateRecipeHandle_t const * recipe);

/** <No documentation available> */
char *
pbb_intermediate_recipe_requirements_run_constraints_remove (
    IntermediateRecipeHandle_t * recipe,
    size_t index);

/** <No documentation available> */
size_t
pbb_intermediate_recipe_requirements_run_len (
    IntermediateRecipeHandle_t const * recipe);

/** <No documentation available> */
char *
pbb_intermediate_recipe_requirements_run_remove (
    IntermediateRecipeHandle_t * recipe,
    size_t index);

/** <No documentation available> */
void
pbb_intermediate_recipe_set_about_description (
    IntermediateRecipeHandle_t * recipe,
    char const * value,
    bool is_template);

/** <No documentation available> */
void
pbb_intermediate_recipe_set_about_documentation (
    IntermediateRecipeHandle_t * recipe,
    char const * value,
    bool is_template);

/** <No documentation available> */
void
pbb_intermediate_recipe_set_about_homepage (
    IntermediateRecipeHandle_t * recipe,
    char const * value,
    bool is_template);

/** <No documentation available> */
void
pbb_intermediate_recipe_set_about_license (
    IntermediateRecipeHandle_t * recipe,
    char const * value,
    bool is_template);

/** <No documentation available> */
void
pbb_intermediate_recipe_set_about_license_file (
    IntermediateRecipeHandle_t * recipe,
    char const * value,
    bool is_template);

/** <No documentation available> */
void
pbb_intermediate_recipe_set_about_repository (
    IntermediateRecipeHandle_t * recipe,
    char const * value,
    bool is_template);

/** <No documentation available> */
void
pbb_intermediate_recipe_set_about_summary (
    IntermediateRecipeHandle_t * recipe,
    char const * value,
    bool is_template);

/** <No documentation available> */
void
pbb_intermediate_recipe_set_build_number (
    IntermediateRecipeHandle_t * recipe,
    bool has_number,
    uint64_t number);

/** <No documentation available> */
void
pbb_intermediate_recipe_set_build_script (
    IntermediateRecipeHandle_t * recipe,
    char const * script);

/** <No documentation available> */
void
pbb_intermediate_recipe_set_noarch (
    IntermediateRecipeHandle_t * recipe,
    NoArchKind_t kind);

/** <No documentation available> */
void
pbb_intermediate_recipe_set_package (
    IntermediateRecipeHandle_t * recipe,
    char const * name,
    bool name_is_template,
    char const * version,
    bool version_is_template);

/** <No documentation available> */
char *
pbb_intermediate_recipe_sources_at (
    IntermediateRecipeHandle_t const * recipe,
    size_t index,
    SourceKind_t * out_kind,
    char * * out_value,
    char * * out_sha256);

/** <No documentation available> */
char *
pbb_intermediate_recipe_sources_conditional_add (
    IntermediateRecipeHandle_t * recipe,
    size_t index,
    ConditionalBranch_t branch,
    SourceInput_t source);

/** <No documentation available> */
char *
pbb_intermediate_recipe_sources_conditional_at (
    IntermediateRecipeHandle_t const * recipe,
    size_t index,
    ConditionalBranch_t branch,
    size_t branch_index,
    SourceKind_t * out_kind,
    char * * out_value,
    char * * out_sha256);

/** <No documentation available> */
char *
pbb_intermediate_recipe_sources_conditional_info (
    IntermediateRecipeHandle_t const * recipe,
    size_t index,
    char * * out_condition,
    size_t * out_then_len,
    size_t * out_else_len);

/** <No documentation available> */
char *
pbb_intermediate_recipe_sources_conditional_len (
    IntermediateRecipeHandle_t const * recipe,
    size_t index,
    ConditionalBranch_t branch,
    size_t * out_len);

/** <No documentation available> */
char *
pbb_intermediate_recipe_sources_conditional_remove (
    IntermediateRecipeHandle_t * recipe,
    size_t index,
    ConditionalBranch_t branch,
    size_t branch_index);

/** <No documentation available> */
size_t
pbb_intermediate_recipe_sources_len (
    IntermediateRecipeHandle_t const * recipe);

/** <No documentation available> */
char *
pbb_intermediate_recipe_sources_remove_at (
    IntermediateRecipeHandle_t * recipe,
    size_t index);

/** <No documentation available> */
char *
pbb_intermediate_recipe_test_has_package_contents (
    IntermediateRecipeHandle_t const * recipe,
    size_t index,
    bool * out_present);

/** <No documentation available> */
char *
pbb_intermediate_recipe_test_package_contents_add_file (
    IntermediateRecipeHandle_t * recipe,
    size_t index,
    char const * value,
    bool is_template);

/** <No documentation available> */
char *
pbb_intermediate_recipe_test_package_contents_add_include (
    IntermediateRecipeHandle_t * recipe,
    size_t index,
    char const * value,
    bool is_template);

/** <No documentation available> */
char *
pbb_intermediate_recipe_test_package_contents_clear_files (
    IntermediateRecipeHandle_t * recipe,
    size_t index);

/** <No documentation available> */
char *
pbb_intermediate_recipe_test_package_contents_clear_include (
    IntermediateRecipeHandle_t * recipe,
    size_t index);

/** <No documentation available> */
char *
pbb_intermediate_recipe_test_package_contents_files_at (
    IntermediateRecipeHandle_t const * recipe,
    size_t index,
    size_t entry_index,
    char * * output);

/** <No documentation available> */
char *
pbb_intermediate_recipe_test_package_contents_files_len (
    IntermediateRecipeHandle_t const * recipe,
    size_t index,
    size_t * out_len);

/** <No documentation available> */
char *
pbb_intermediate_recipe_test_package_contents_files_remove (
    IntermediateRecipeHandle_t * recipe,
    size_t index,
    size_t entry_index);

/** <No documentation available> */
char *
pbb_intermediate_recipe_test_package_contents_include_at (
    IntermediateRecipeHandle_t const * recipe,
    size_t index,
    size_t entry_index,
    char * * output);

/** <No documentation available> */
char *
pbb_intermediate_recipe_test_package_contents_include_len (
    IntermediateRecipeHandle_t const * recipe,
    size_t index,
    size_t * out_len);

/** <No documentation available> */
char *
pbb_intermediate_recipe_test_package_contents_include_remove (
    IntermediateRecipeHandle_t * recipe,
    size_t index,
    size_t entry_index);

/** <No documentation available> */
char *
pbb_intermediate_recipe_test_set_package_contents_present (
    IntermediateRecipeHandle_t * recipe,
    size_t index,
    bool present);

/** <No documentation available> */
void
pbb_intermediate_recipe_tests_clear (
    IntermediateRecipeHandle_t * recipe);

/** <No documentation available> */
size_t
pbb_intermediate_recipe_tests_len (
    IntermediateRecipeHandle_t const * recipe);

/** <No documentation available> */
void
pbb_intermediate_recipe_tests_push (
    IntermediateRecipeHandle_t * recipe);

/** <No documentation available> */
char *
pbb_intermediate_recipe_tests_remove (
    IntermediateRecipeHandle_t * recipe,
    size_t index);

/** <No documentation available> */
char *
pbb_intermediate_recipe_to_yaml (
    IntermediateRecipeHandle_t const * recipe);

/** <No documentation available> */
typedef struct CMetadataProviderVTable {
    /** <No documentation available> */
    void (*release_vptr)(Erased_t *);

    /** <No documentation available> */
    char * (*name)(Erased_t *, char * *);

    /** <No documentation available> */
    char * (*version)(Erased_t *, char * *);

    /** <No documentation available> */
    char * (*homepage)(Erased_t *, char * *);

    /** <No documentation available> */
    char * (*license)(Erased_t *, char * *);

    /** <No documentation available> */
    char * (*license_file)(Erased_t *, char * *);

    /** <No documentation available> */
    char * (*summary)(Erased_t *, char * *);

    /** <No documentation available> */
    char * (*description)(Erased_t *, char * *);

    /** <No documentation available> */
    char * (*documentation)(Erased_t *, char * *);

    /** <No documentation available> */
    char * (*repository)(Erased_t *, char * *);
} CMetadataProviderVTable_t;

/** <No documentation available> */
typedef struct VirtualPtr__Erased_ptr_CMetadataProviderVTable {
    /** <No documentation available> */
    Erased_t * ptr;

    /** <No documentation available> */
    CMetadataProviderVTable_t vtable;
} VirtualPtr__Erased_ptr_CMetadataProviderVTable_t;

/** <No documentation available> */
typedef struct MetadataProvider {
    /** <No documentation available> */
    VirtualPtr__Erased_ptr_CMetadataProviderVTable_t provider;
} MetadataProvider_t;

/** <No documentation available> */
MetadataProvider_t
ppb_metadata_provider_new (
    VirtualPtr__Erased_ptr_CMetadataProviderVTable_t provider);

/** <No documentation available> */
typedef struct BinaryPackageSpecV1 {
    /** \brief
     *  The version spec of the package (e.g. `1.2.3`, `>=1.2.3`, `1.2.*`)
     */
    char * version;

    /** \brief
     *  The build string of the package (e.g. `py37_0`, `py37h6de7cb9_0`, `py*`)
     */
    char * build;

    /** \brief
     *  The build number of the package
     */
    char * build_number;

    /** \brief
     *  Match the specific filename of the package
     */
    char * file_name;

    /** \brief
     *  The channel of the package
     */
    char * channel;

    /** \brief
     *  The subdir of the channel
     */
    char * subdir;

    /** \brief
     *  The md5 hash of the package
     */
    char * md5;

    /** \brief
     *  The sha256 hash of the package
     */
    char * sha256;

    /** \brief
     *  The URL of the package, if it is available
     */
    char * url;

    /** \brief
     *  The license of the package
     */
    char * license;
} BinaryPackageSpecV1_t;

/** <No documentation available> */
typedef struct PackageSpecV1 PackageSpecV1_t;

/** <No documentation available> */
char *
ppb_package_spec_v1_binary_new (
    BinaryPackageSpecV1_t spec,
    PackageSpecV1_t * * output);

/** <No documentation available> */
typedef struct SourcePackageSpecV1 SourcePackageSpecV1_t;

/** <No documentation available> */
char *
ppb_package_spec_v1_source_new (
    SourcePackageSpecV1_t * spec,
    PackageSpecV1_t * * output);

/** \brief
 *  A `struct` usable from both Rust and C
 */
/** \remark Has the same ABI as `uint8_t` **/
#ifdef DOXYGEN
typedef
#endif
enum Platform {
    /** <No documentation available> */
    PLATFORM_NO_ARCH,
    /** <No documentation available> */
    PLATFORM_UNKNOWN,
    /** <No documentation available> */
    PLATFORM_LINUX32,
    /** <No documentation available> */
    PLATFORM_LINUX64,
    /** <No documentation available> */
    PLATFORM_LINUX_AARCH64,
    /** <No documentation available> */
    PLATFORM_LINUX_ARM_V6L,
    /** <No documentation available> */
    PLATFORM_LINUX_ARM_V7L,
    /** <No documentation available> */
    PLATFORM_LINUX_LOONG64,
    /** <No documentation available> */
    PLATFORM_LINUX_PPC64LE,
    /** <No documentation available> */
    PLATFORM_LINUX_PPC64,
    /** <No documentation available> */
    PLATFORM_LINUX_PPC,
    /** <No documentation available> */
    PLATFORM_LINUX_S390_X,
    /** <No documentation available> */
    PLATFORM_LINUX_RISCV32,
    /** <No documentation available> */
    PLATFORM_LINUX_RISCV64,
    /** <No documentation available> */
    PLATFORM_OSX64,
    /** <No documentation available> */
    PLATFORM_OSX_ARM64,
    /** <No documentation available> */
    PLATFORM_WIN32,
    /** <No documentation available> */
    PLATFORM_WIN64,
    /** <No documentation available> */
    PLATFORM_WIN_ARM64,
    /** <No documentation available> */
    PLATFORM_EMSCRIPTEN_WASM32,
    /** <No documentation available> */
    PLATFORM_WASI_WASM32,
    /** <No documentation available> */
    PLATFORM_ZOS_Z,
}
#ifndef DOXYGEN
; typedef uint8_t
#endif
Platform_t;

/** <No documentation available> */
Platform_t
ppb_platform_current (void);

/** <No documentation available> */
bool
ppb_platform_is_linux (
    Platform_t const * p);

/** <No documentation available> */
bool
ppb_platform_is_osx (
    Platform_t const * p);

/** <No documentation available> */
bool
ppb_platform_is_unix (
    Platform_t const * p);

/** <No documentation available> */
bool
ppb_platform_is_windows (
    Platform_t const * p);

/** \brief
 *  Don't forget to free returned value.
 */
char *
ppb_platform_name (
    Platform_t const * p);

/** <No documentation available> */
char *
ppb_platform_only_platform (
    Platform_t const * p);

/** <No documentation available> */
typedef struct GitSpecV1 {
    /** \brief
     *  The git url of the package which can contain git+ prefixes.
     */
    char * git;

    /** \brief
     *  The git revision of the package
     */
    GitReferenceV1_t * rev;

    /** \brief
     *  The git subdirectory of the package
     */
    char * subdirectory;
} GitSpecV1_t;

/** <No documentation available> */
char *
ppb_source_package_spec_v1_git_new (
    GitSpecV1_t spec,
    SourcePackageSpecV1_t * * output);

/** <No documentation available> */
typedef struct PathSpecV1 {
    /** <No documentation available> */
    char * path;
} PathSpecV1_t;

/** <No documentation available> */
SourcePackageSpecV1_t *
ppb_source_package_spec_v1_path_new (
    PathSpecV1_t spec);

/** <No documentation available> */
typedef struct UrlSpecV1 {
    /** <No documentation available> */
    char * url;

    /** <No documentation available> */
    char * md5;

    /** <No documentation available> */
    char * sha256;
} UrlSpecV1_t;

/** <No documentation available> */
char *
ppb_source_package_spec_v1_url_new (
    UrlSpecV1_t spec,
    SourcePackageSpecV1_t * * output);


#ifdef __cplusplus
} /* extern \"C\" */
#endif

#endif /* __RUST_C_PIXI_BUILD_BACKEND__ */
